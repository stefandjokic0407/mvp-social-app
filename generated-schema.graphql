# -----------------------------------------------
# !!! THIS FILE WAS GENERATED BY TYPE-GRAPHQL !!!
# !!!   DO NOT MODIFY THIS FILE BY YOURSELF   !!!
# -----------------------------------------------

type AffectedRowsOutput {
  count: Int!
}

type AggregateTotym {
  _avg: TotymAvgAggregate
  _count: TotymCountAggregate
  _max: TotymMaxAggregate
  _min: TotymMinAggregate
  _sum: TotymSumAggregate
}

type AggregateUser {
  _avg: UserAvgAggregate
  _count: UserCountAggregate
  _max: UserMaxAggregate
  _min: UserMinAggregate
  _sum: UserSumAggregate
}

"""
The javascript `Date` as string. Type represents date and time as the ISO Date string.
"""
scalar DateTime

input DateTimeFieldUpdateOperationsInput {
  set: DateTime
}

input DateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeFilter
  notIn: [DateTime!]
}

input DateTimeNullableFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeNullableFilter
  notIn: [DateTime!]
}

input DateTimeNullableWithAggregatesFilter {
  _count: NestedIntNullableFilter
  _max: NestedDateTimeNullableFilter
  _min: NestedDateTimeNullableFilter
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeNullableWithAggregatesFilter
  notIn: [DateTime!]
}

input DateTimeWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedDateTimeFilter
  _min: NestedDateTimeFilter
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeWithAggregatesFilter
  notIn: [DateTime!]
}

input EnumRoleFieldUpdateOperationsInput {
  set: Role
}

input EnumRoleFilter {
  equals: Role
  in: [Role!]
  not: NestedEnumRoleFilter
  notIn: [Role!]
}

input EnumRoleWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedEnumRoleFilter
  _min: NestedEnumRoleFilter
  equals: Role
  in: [Role!]
  not: NestedEnumRoleWithAggregatesFilter
  notIn: [Role!]
}

input IntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int!]
}

input IntWithAggregatesFilter {
  _avg: NestedFloatFilter
  _count: NestedIntFilter
  _max: NestedIntFilter
  _min: NestedIntFilter
  _sum: NestedIntFilter
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntWithAggregatesFilter
  notIn: [Int!]
}

type Item {
  address: String
  description: String
  id: Int!
  image: String
  link: String
  name: String!
  totymId: Int!
}

input ItemCreateManyTotymInput {
  address: String
  description: String
  id: Int
  image: String
  link: String
  name: String!
}

input ItemCreateManyTotymInputEnvelope {
  data: [ItemCreateManyTotymInput!]!
  skipDuplicates: Boolean
}

input ItemCreateNestedManyWithoutTotymInput {
  connect: [ItemWhereUniqueInput!]
  connectOrCreate: [ItemCreateOrConnectWithoutTotymInput!]
  create: [ItemCreateWithoutTotymInput!]
  createMany: ItemCreateManyTotymInputEnvelope
}

input ItemCreateOrConnectWithoutTotymInput {
  create: ItemCreateWithoutTotymInput!
  where: ItemWhereUniqueInput!
}

input ItemCreateWithoutTotymInput {
  address: String
  description: String
  image: String
  link: String
  name: String!
}

input ItemListRelationFilter {
  every: ItemWhereInput
  none: ItemWhereInput
  some: ItemWhereInput
}

input ItemOrderByInput {
  address: SortOrder
  description: SortOrder
  id: SortOrder
  image: SortOrder
  link: SortOrder
  name: SortOrder
  totymId: SortOrder
}

enum ItemScalarFieldEnum {
  address
  description
  id
  image
  link
  name
  totymId
}

input ItemScalarWhereInput {
  AND: [ItemScalarWhereInput!]
  NOT: [ItemScalarWhereInput!]
  OR: [ItemScalarWhereInput!]
  address: StringNullableFilter
  description: StringNullableFilter
  id: IntFilter
  image: StringNullableFilter
  link: StringNullableFilter
  name: StringFilter
  totymId: IntFilter
}

input ItemUpdateManyMutationInput {
  address: NullableStringFieldUpdateOperationsInput
  description: NullableStringFieldUpdateOperationsInput
  image: NullableStringFieldUpdateOperationsInput
  link: NullableStringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
}

input ItemUpdateManyWithWhereWithoutTotymInput {
  data: ItemUpdateManyMutationInput!
  where: ItemScalarWhereInput!
}

input ItemUpdateManyWithoutTotymInput {
  connect: [ItemWhereUniqueInput!]
  connectOrCreate: [ItemCreateOrConnectWithoutTotymInput!]
  create: [ItemCreateWithoutTotymInput!]
  createMany: ItemCreateManyTotymInputEnvelope
  delete: [ItemWhereUniqueInput!]
  deleteMany: [ItemScalarWhereInput!]
  disconnect: [ItemWhereUniqueInput!]
  set: [ItemWhereUniqueInput!]
  update: [ItemUpdateWithWhereUniqueWithoutTotymInput!]
  updateMany: [ItemUpdateManyWithWhereWithoutTotymInput!]
  upsert: [ItemUpsertWithWhereUniqueWithoutTotymInput!]
}

input ItemUpdateWithWhereUniqueWithoutTotymInput {
  data: ItemUpdateWithoutTotymInput!
  where: ItemWhereUniqueInput!
}

input ItemUpdateWithoutTotymInput {
  address: NullableStringFieldUpdateOperationsInput
  description: NullableStringFieldUpdateOperationsInput
  image: NullableStringFieldUpdateOperationsInput
  link: NullableStringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
}

input ItemUpsertWithWhereUniqueWithoutTotymInput {
  create: ItemCreateWithoutTotymInput!
  update: ItemUpdateWithoutTotymInput!
  where: ItemWhereUniqueInput!
}

input ItemWhereInput {
  AND: [ItemWhereInput!]
  NOT: [ItemWhereInput!]
  OR: [ItemWhereInput!]
  address: StringNullableFilter
  description: StringNullableFilter
  id: IntFilter
  image: StringNullableFilter
  link: StringNullableFilter
  name: StringFilter
  totym: TotymRelationFilter
  totymId: IntFilter
}

input ItemWhereUniqueInput {
  id: Int
}

type Mutation {
  createManyTotym(data: [TotymCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyUser(data: [UserCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createTotym(data: TotymCreateInput!): Totym!
  createUser(data: UserCreateInput!): User!
  deleteManyTotym(where: TotymWhereInput): AffectedRowsOutput!
  deleteManyUser(where: UserWhereInput): AffectedRowsOutput!
  deleteTotym(where: TotymWhereUniqueInput!): Totym
  deleteUser(where: UserWhereUniqueInput!): User
  updateManyTotym(data: TotymUpdateManyMutationInput!, where: TotymWhereInput): AffectedRowsOutput!
  updateManyUser(data: UserUpdateManyMutationInput!, where: UserWhereInput): AffectedRowsOutput!
  updateTotym(data: TotymUpdateInput!, where: TotymWhereUniqueInput!): Totym
  updateUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
  upsertTotym(create: TotymCreateInput!, update: TotymUpdateInput!, where: TotymWhereUniqueInput!): Totym!
  upsertUser(create: UserCreateInput!, update: UserUpdateInput!, where: UserWhereUniqueInput!): User!
}

input NestedDateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeFilter
  notIn: [DateTime!]
}

input NestedDateTimeNullableFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeNullableFilter
  notIn: [DateTime!]
}

input NestedDateTimeNullableWithAggregatesFilter {
  _count: NestedIntNullableFilter
  _max: NestedDateTimeNullableFilter
  _min: NestedDateTimeNullableFilter
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeNullableWithAggregatesFilter
  notIn: [DateTime!]
}

input NestedDateTimeWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedDateTimeFilter
  _min: NestedDateTimeFilter
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeWithAggregatesFilter
  notIn: [DateTime!]
}

input NestedEnumRoleFilter {
  equals: Role
  in: [Role!]
  not: NestedEnumRoleFilter
  notIn: [Role!]
}

input NestedEnumRoleWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedEnumRoleFilter
  _min: NestedEnumRoleFilter
  equals: Role
  in: [Role!]
  not: NestedEnumRoleWithAggregatesFilter
  notIn: [Role!]
}

input NestedFloatFilter {
  equals: Float
  gt: Float
  gte: Float
  in: [Float!]
  lt: Float
  lte: Float
  not: NestedFloatFilter
  notIn: [Float!]
}

input NestedIntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int!]
}

input NestedIntNullableFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntNullableFilter
  notIn: [Int!]
}

input NestedIntWithAggregatesFilter {
  _avg: NestedFloatFilter
  _count: NestedIntFilter
  _max: NestedIntFilter
  _min: NestedIntFilter
  _sum: NestedIntFilter
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntWithAggregatesFilter
  notIn: [Int!]
}

input NestedStringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input NestedStringNullableFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringNullableFilter
  notIn: [String!]
  startsWith: String
}

input NestedStringNullableWithAggregatesFilter {
  _count: NestedIntNullableFilter
  _max: NestedStringNullableFilter
  _min: NestedStringNullableFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringNullableWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}

input NestedStringWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedStringFilter
  _min: NestedStringFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}

input NullableDateTimeFieldUpdateOperationsInput {
  set: DateTime
}

input NullableStringFieldUpdateOperationsInput {
  set: String
}

type Query {
  aggregateTotym(cursor: TotymWhereUniqueInput, orderBy: [TotymOrderByInput!], skip: Int, take: Int, where: TotymWhereInput): AggregateTotym!
  aggregateUser(cursor: UserWhereUniqueInput, orderBy: [UserOrderByInput!], skip: Int, take: Int, where: UserWhereInput): AggregateUser!
  findFirstTotym(cursor: TotymWhereUniqueInput, distinct: [TotymScalarFieldEnum!], orderBy: [TotymOrderByInput!], skip: Int, take: Int, where: TotymWhereInput): Totym
  findFirstUser(cursor: UserWhereUniqueInput, distinct: [UserScalarFieldEnum!], orderBy: [UserOrderByInput!], skip: Int, take: Int, where: UserWhereInput): User
  groupByTotym(by: [TotymScalarFieldEnum!]!, having: TotymScalarWhereWithAggregatesInput, orderBy: [TotymOrderByInput!], skip: Int, take: Int, where: TotymWhereInput): [TotymGroupBy!]!
  groupByUser(by: [UserScalarFieldEnum!]!, having: UserScalarWhereWithAggregatesInput, orderBy: [UserOrderByInput!], skip: Int, take: Int, where: UserWhereInput): [UserGroupBy!]!
  totym(where: TotymWhereUniqueInput!): Totym
  totyms(cursor: TotymWhereUniqueInput, distinct: [TotymScalarFieldEnum!], orderBy: [TotymOrderByInput!], skip: Int, take: Int, where: TotymWhereInput): [Totym!]!
  user(where: UserWhereUniqueInput!): User
  users(cursor: UserWhereUniqueInput, distinct: [UserScalarFieldEnum!], orderBy: [UserOrderByInput!], skip: Int, take: Int, where: UserWhereInput): [User!]!
}

enum QueryMode {
  default
  insensitive
}

enum Role {
  ADMIN
  USER
}

enum SortOrder {
  asc
  desc
}

input StringFieldUpdateOperationsInput {
  set: String
}

input StringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input StringNullableFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringNullableFilter
  notIn: [String!]
  startsWith: String
}

input StringNullableWithAggregatesFilter {
  _count: NestedIntNullableFilter
  _max: NestedStringNullableFilter
  _min: NestedStringNullableFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringNullableWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}

input StringWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedStringFilter
  _min: NestedStringFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}

type Totym {
  coverPhoto: String
  createdAt: DateTime!
  description: String
  id: Int!
  items(cursor: ItemWhereUniqueInput, distinct: [ItemScalarFieldEnum!], orderBy: [ItemOrderByInput!], skip: Int, take: Int, where: ItemWhereInput): [Item!]!
  location: String
  title: String!
  updatedAt: DateTime!
  user: User!
  userId: Int!
}

type TotymAvgAggregate {
  id: Float
  userId: Float
}

type TotymCountAggregate {
  _all: Int!
  coverPhoto: Int!
  createdAt: Int!
  description: Int!
  id: Int!
  location: Int!
  title: Int!
  updatedAt: Int!
  userId: Int!
}

input TotymCreateInput {
  coverPhoto: String
  createdAt: DateTime
  description: String
  items: ItemCreateNestedManyWithoutTotymInput
  location: String
  title: String!
  updatedAt: DateTime
  user: UserCreateNestedOneWithoutTotymsInput!
}

input TotymCreateManyInput {
  coverPhoto: String
  createdAt: DateTime
  description: String
  id: Int
  location: String
  title: String!
  updatedAt: DateTime
  userId: Int!
}

input TotymCreateManyUserInput {
  coverPhoto: String
  createdAt: DateTime
  description: String
  id: Int
  location: String
  title: String!
  updatedAt: DateTime
}

input TotymCreateManyUserInputEnvelope {
  data: [TotymCreateManyUserInput!]!
  skipDuplicates: Boolean
}

input TotymCreateNestedManyWithoutUserInput {
  connect: [TotymWhereUniqueInput!]
  connectOrCreate: [TotymCreateOrConnectWithoutUserInput!]
  create: [TotymCreateWithoutUserInput!]
  createMany: TotymCreateManyUserInputEnvelope
}

input TotymCreateOrConnectWithoutUserInput {
  create: TotymCreateWithoutUserInput!
  where: TotymWhereUniqueInput!
}

input TotymCreateWithoutUserInput {
  coverPhoto: String
  createdAt: DateTime
  description: String
  items: ItemCreateNestedManyWithoutTotymInput
  location: String
  title: String!
  updatedAt: DateTime
}

type TotymGroupBy {
  _avg: TotymAvgAggregate
  _count: TotymCountAggregate
  _max: TotymMaxAggregate
  _min: TotymMinAggregate
  _sum: TotymSumAggregate
  coverPhoto: String
  createdAt: DateTime!
  description: String
  id: Int!
  location: String
  title: String!
  updatedAt: DateTime!
  userId: Int!
}

input TotymListRelationFilter {
  every: TotymWhereInput
  none: TotymWhereInput
  some: TotymWhereInput
}

type TotymMaxAggregate {
  coverPhoto: String
  createdAt: DateTime
  description: String
  id: Int
  location: String
  title: String
  updatedAt: DateTime
  userId: Int
}

type TotymMinAggregate {
  coverPhoto: String
  createdAt: DateTime
  description: String
  id: Int
  location: String
  title: String
  updatedAt: DateTime
  userId: Int
}

input TotymOrderByInput {
  coverPhoto: SortOrder
  createdAt: SortOrder
  description: SortOrder
  id: SortOrder
  location: SortOrder
  title: SortOrder
  updatedAt: SortOrder
  userId: SortOrder
}

input TotymRelationFilter {
  is: TotymWhereInput
  isNot: TotymWhereInput
}

enum TotymScalarFieldEnum {
  coverPhoto
  createdAt
  description
  id
  location
  title
  updatedAt
  userId
}

input TotymScalarWhereInput {
  AND: [TotymScalarWhereInput!]
  NOT: [TotymScalarWhereInput!]
  OR: [TotymScalarWhereInput!]
  coverPhoto: StringNullableFilter
  createdAt: DateTimeFilter
  description: StringNullableFilter
  id: IntFilter
  location: StringNullableFilter
  title: StringFilter
  updatedAt: DateTimeFilter
  userId: IntFilter
}

input TotymScalarWhereWithAggregatesInput {
  AND: [TotymScalarWhereWithAggregatesInput!]
  NOT: [TotymScalarWhereWithAggregatesInput!]
  OR: [TotymScalarWhereWithAggregatesInput!]
  coverPhoto: StringNullableWithAggregatesFilter
  createdAt: DateTimeWithAggregatesFilter
  description: StringNullableWithAggregatesFilter
  id: IntWithAggregatesFilter
  location: StringNullableWithAggregatesFilter
  title: StringWithAggregatesFilter
  updatedAt: DateTimeWithAggregatesFilter
  userId: IntWithAggregatesFilter
}

type TotymSumAggregate {
  id: Int
  userId: Int
}

input TotymUpdateInput {
  coverPhoto: NullableStringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  description: NullableStringFieldUpdateOperationsInput
  items: ItemUpdateManyWithoutTotymInput
  location: NullableStringFieldUpdateOperationsInput
  title: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  user: UserUpdateOneRequiredWithoutTotymsInput
}

input TotymUpdateManyMutationInput {
  coverPhoto: NullableStringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  description: NullableStringFieldUpdateOperationsInput
  location: NullableStringFieldUpdateOperationsInput
  title: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input TotymUpdateManyWithWhereWithoutUserInput {
  data: TotymUpdateManyMutationInput!
  where: TotymScalarWhereInput!
}

input TotymUpdateManyWithoutUserInput {
  connect: [TotymWhereUniqueInput!]
  connectOrCreate: [TotymCreateOrConnectWithoutUserInput!]
  create: [TotymCreateWithoutUserInput!]
  createMany: TotymCreateManyUserInputEnvelope
  delete: [TotymWhereUniqueInput!]
  deleteMany: [TotymScalarWhereInput!]
  disconnect: [TotymWhereUniqueInput!]
  set: [TotymWhereUniqueInput!]
  update: [TotymUpdateWithWhereUniqueWithoutUserInput!]
  updateMany: [TotymUpdateManyWithWhereWithoutUserInput!]
  upsert: [TotymUpsertWithWhereUniqueWithoutUserInput!]
}

input TotymUpdateWithWhereUniqueWithoutUserInput {
  data: TotymUpdateWithoutUserInput!
  where: TotymWhereUniqueInput!
}

input TotymUpdateWithoutUserInput {
  coverPhoto: NullableStringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  description: NullableStringFieldUpdateOperationsInput
  items: ItemUpdateManyWithoutTotymInput
  location: NullableStringFieldUpdateOperationsInput
  title: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input TotymUpsertWithWhereUniqueWithoutUserInput {
  create: TotymCreateWithoutUserInput!
  update: TotymUpdateWithoutUserInput!
  where: TotymWhereUniqueInput!
}

input TotymWhereInput {
  AND: [TotymWhereInput!]
  NOT: [TotymWhereInput!]
  OR: [TotymWhereInput!]
  coverPhoto: StringNullableFilter
  createdAt: DateTimeFilter
  description: StringNullableFilter
  id: IntFilter
  items: ItemListRelationFilter
  location: StringNullableFilter
  title: StringFilter
  updatedAt: DateTimeFilter
  user: UserRelationFilter
  userId: IntFilter
}

input TotymWhereUniqueInput {
  id: Int
}

type User {
  avatar: String
  createdAt: DateTime!
  email: String!
  emailVerified: DateTime
  followers(cursor: UserWhereUniqueInput, distinct: [UserScalarFieldEnum!], orderBy: [UserOrderByInput!], skip: Int, take: Int, where: UserWhereInput): [User!]!
  following(cursor: UserWhereUniqueInput, distinct: [UserScalarFieldEnum!], orderBy: [UserOrderByInput!], skip: Int, take: Int, where: UserWhereInput): [User!]!
  id: Int!
  name: String
  role: Role!
  totyms(cursor: TotymWhereUniqueInput, distinct: [TotymScalarFieldEnum!], orderBy: [TotymOrderByInput!], skip: Int, take: Int, where: TotymWhereInput): [Totym!]!
  updatedAt: DateTime!
  username: String
}

type UserAvgAggregate {
  id: Float
}

type UserCountAggregate {
  _all: Int!
  avatar: Int!
  createdAt: Int!
  email: Int!
  emailVerified: Int!
  id: Int!
  name: Int!
  role: Int!
  updatedAt: Int!
  username: Int!
}

input UserCreateInput {
  avatar: String
  createdAt: DateTime
  email: String!
  emailVerified: DateTime
  followers: UserCreateNestedManyWithoutFollowingInput
  following: UserCreateNestedManyWithoutFollowersInput
  name: String
  role: Role
  totyms: TotymCreateNestedManyWithoutUserInput
  updatedAt: DateTime
  username: String
}

input UserCreateManyInput {
  avatar: String
  createdAt: DateTime
  email: String!
  emailVerified: DateTime
  id: Int
  name: String
  role: Role
  updatedAt: DateTime
  username: String
}

input UserCreateNestedManyWithoutFollowersInput {
  connect: [UserWhereUniqueInput!]
  connectOrCreate: [UserCreateOrConnectWithoutFollowersInput!]
  create: [UserCreateWithoutFollowersInput!]
}

input UserCreateNestedManyWithoutFollowingInput {
  connect: [UserWhereUniqueInput!]
  connectOrCreate: [UserCreateOrConnectWithoutFollowingInput!]
  create: [UserCreateWithoutFollowingInput!]
}

input UserCreateNestedOneWithoutTotymsInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutTotymsInput
  create: UserCreateWithoutTotymsInput
}

input UserCreateOrConnectWithoutFollowersInput {
  create: UserCreateWithoutFollowersInput!
  where: UserWhereUniqueInput!
}

input UserCreateOrConnectWithoutFollowingInput {
  create: UserCreateWithoutFollowingInput!
  where: UserWhereUniqueInput!
}

input UserCreateOrConnectWithoutTotymsInput {
  create: UserCreateWithoutTotymsInput!
  where: UserWhereUniqueInput!
}

input UserCreateWithoutFollowersInput {
  avatar: String
  createdAt: DateTime
  email: String!
  emailVerified: DateTime
  following: UserCreateNestedManyWithoutFollowersInput
  name: String
  role: Role
  totyms: TotymCreateNestedManyWithoutUserInput
  updatedAt: DateTime
  username: String
}

input UserCreateWithoutFollowingInput {
  avatar: String
  createdAt: DateTime
  email: String!
  emailVerified: DateTime
  followers: UserCreateNestedManyWithoutFollowingInput
  name: String
  role: Role
  totyms: TotymCreateNestedManyWithoutUserInput
  updatedAt: DateTime
  username: String
}

input UserCreateWithoutTotymsInput {
  avatar: String
  createdAt: DateTime
  email: String!
  emailVerified: DateTime
  followers: UserCreateNestedManyWithoutFollowingInput
  following: UserCreateNestedManyWithoutFollowersInput
  name: String
  role: Role
  updatedAt: DateTime
  username: String
}

type UserGroupBy {
  _avg: UserAvgAggregate
  _count: UserCountAggregate
  _max: UserMaxAggregate
  _min: UserMinAggregate
  _sum: UserSumAggregate
  avatar: String
  createdAt: DateTime!
  email: String!
  emailVerified: DateTime
  id: Int!
  name: String
  role: Role!
  updatedAt: DateTime!
  username: String
}

input UserListRelationFilter {
  every: UserWhereInput
  none: UserWhereInput
  some: UserWhereInput
}

type UserMaxAggregate {
  avatar: String
  createdAt: DateTime
  email: String
  emailVerified: DateTime
  id: Int
  name: String
  role: Role
  updatedAt: DateTime
  username: String
}

type UserMinAggregate {
  avatar: String
  createdAt: DateTime
  email: String
  emailVerified: DateTime
  id: Int
  name: String
  role: Role
  updatedAt: DateTime
  username: String
}

input UserOrderByInput {
  avatar: SortOrder
  createdAt: SortOrder
  email: SortOrder
  emailVerified: SortOrder
  id: SortOrder
  name: SortOrder
  role: SortOrder
  updatedAt: SortOrder
  username: SortOrder
}

input UserRelationFilter {
  is: UserWhereInput
  isNot: UserWhereInput
}

enum UserScalarFieldEnum {
  avatar
  createdAt
  email
  emailVerified
  id
  name
  role
  updatedAt
  username
}

input UserScalarWhereInput {
  AND: [UserScalarWhereInput!]
  NOT: [UserScalarWhereInput!]
  OR: [UserScalarWhereInput!]
  avatar: StringNullableFilter
  createdAt: DateTimeFilter
  email: StringFilter
  emailVerified: DateTimeNullableFilter
  id: IntFilter
  name: StringNullableFilter
  role: EnumRoleFilter
  updatedAt: DateTimeFilter
  username: StringNullableFilter
}

input UserScalarWhereWithAggregatesInput {
  AND: [UserScalarWhereWithAggregatesInput!]
  NOT: [UserScalarWhereWithAggregatesInput!]
  OR: [UserScalarWhereWithAggregatesInput!]
  avatar: StringNullableWithAggregatesFilter
  createdAt: DateTimeWithAggregatesFilter
  email: StringWithAggregatesFilter
  emailVerified: DateTimeNullableWithAggregatesFilter
  id: IntWithAggregatesFilter
  name: StringNullableWithAggregatesFilter
  role: EnumRoleWithAggregatesFilter
  updatedAt: DateTimeWithAggregatesFilter
  username: StringNullableWithAggregatesFilter
}

type UserSumAggregate {
  id: Int
}

input UserUpdateInput {
  avatar: NullableStringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  email: StringFieldUpdateOperationsInput
  emailVerified: NullableDateTimeFieldUpdateOperationsInput
  followers: UserUpdateManyWithoutFollowingInput
  following: UserUpdateManyWithoutFollowersInput
  name: NullableStringFieldUpdateOperationsInput
  role: EnumRoleFieldUpdateOperationsInput
  totyms: TotymUpdateManyWithoutUserInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  username: NullableStringFieldUpdateOperationsInput
}

input UserUpdateManyMutationInput {
  avatar: NullableStringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  email: StringFieldUpdateOperationsInput
  emailVerified: NullableDateTimeFieldUpdateOperationsInput
  name: NullableStringFieldUpdateOperationsInput
  role: EnumRoleFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  username: NullableStringFieldUpdateOperationsInput
}

input UserUpdateManyWithWhereWithoutFollowersInput {
  data: UserUpdateManyMutationInput!
  where: UserScalarWhereInput!
}

input UserUpdateManyWithWhereWithoutFollowingInput {
  data: UserUpdateManyMutationInput!
  where: UserScalarWhereInput!
}

input UserUpdateManyWithoutFollowersInput {
  connect: [UserWhereUniqueInput!]
  connectOrCreate: [UserCreateOrConnectWithoutFollowersInput!]
  create: [UserCreateWithoutFollowersInput!]
  delete: [UserWhereUniqueInput!]
  deleteMany: [UserScalarWhereInput!]
  disconnect: [UserWhereUniqueInput!]
  set: [UserWhereUniqueInput!]
  update: [UserUpdateWithWhereUniqueWithoutFollowersInput!]
  updateMany: [UserUpdateManyWithWhereWithoutFollowersInput!]
  upsert: [UserUpsertWithWhereUniqueWithoutFollowersInput!]
}

input UserUpdateManyWithoutFollowingInput {
  connect: [UserWhereUniqueInput!]
  connectOrCreate: [UserCreateOrConnectWithoutFollowingInput!]
  create: [UserCreateWithoutFollowingInput!]
  delete: [UserWhereUniqueInput!]
  deleteMany: [UserScalarWhereInput!]
  disconnect: [UserWhereUniqueInput!]
  set: [UserWhereUniqueInput!]
  update: [UserUpdateWithWhereUniqueWithoutFollowingInput!]
  updateMany: [UserUpdateManyWithWhereWithoutFollowingInput!]
  upsert: [UserUpsertWithWhereUniqueWithoutFollowingInput!]
}

input UserUpdateOneRequiredWithoutTotymsInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutTotymsInput
  create: UserCreateWithoutTotymsInput
  update: UserUpdateWithoutTotymsInput
  upsert: UserUpsertWithoutTotymsInput
}

input UserUpdateWithWhereUniqueWithoutFollowersInput {
  data: UserUpdateWithoutFollowersInput!
  where: UserWhereUniqueInput!
}

input UserUpdateWithWhereUniqueWithoutFollowingInput {
  data: UserUpdateWithoutFollowingInput!
  where: UserWhereUniqueInput!
}

input UserUpdateWithoutFollowersInput {
  avatar: NullableStringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  email: StringFieldUpdateOperationsInput
  emailVerified: NullableDateTimeFieldUpdateOperationsInput
  following: UserUpdateManyWithoutFollowersInput
  name: NullableStringFieldUpdateOperationsInput
  role: EnumRoleFieldUpdateOperationsInput
  totyms: TotymUpdateManyWithoutUserInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  username: NullableStringFieldUpdateOperationsInput
}

input UserUpdateWithoutFollowingInput {
  avatar: NullableStringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  email: StringFieldUpdateOperationsInput
  emailVerified: NullableDateTimeFieldUpdateOperationsInput
  followers: UserUpdateManyWithoutFollowingInput
  name: NullableStringFieldUpdateOperationsInput
  role: EnumRoleFieldUpdateOperationsInput
  totyms: TotymUpdateManyWithoutUserInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  username: NullableStringFieldUpdateOperationsInput
}

input UserUpdateWithoutTotymsInput {
  avatar: NullableStringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  email: StringFieldUpdateOperationsInput
  emailVerified: NullableDateTimeFieldUpdateOperationsInput
  followers: UserUpdateManyWithoutFollowingInput
  following: UserUpdateManyWithoutFollowersInput
  name: NullableStringFieldUpdateOperationsInput
  role: EnumRoleFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  username: NullableStringFieldUpdateOperationsInput
}

input UserUpsertWithWhereUniqueWithoutFollowersInput {
  create: UserCreateWithoutFollowersInput!
  update: UserUpdateWithoutFollowersInput!
  where: UserWhereUniqueInput!
}

input UserUpsertWithWhereUniqueWithoutFollowingInput {
  create: UserCreateWithoutFollowingInput!
  update: UserUpdateWithoutFollowingInput!
  where: UserWhereUniqueInput!
}

input UserUpsertWithoutTotymsInput {
  create: UserCreateWithoutTotymsInput!
  update: UserUpdateWithoutTotymsInput!
}

input UserWhereInput {
  AND: [UserWhereInput!]
  NOT: [UserWhereInput!]
  OR: [UserWhereInput!]
  avatar: StringNullableFilter
  createdAt: DateTimeFilter
  email: StringFilter
  emailVerified: DateTimeNullableFilter
  followers: UserListRelationFilter
  following: UserListRelationFilter
  id: IntFilter
  name: StringNullableFilter
  role: EnumRoleFilter
  totyms: TotymListRelationFilter
  updatedAt: DateTimeFilter
  username: StringNullableFilter
}

input UserWhereUniqueInput {
  email: String
  id: Int
  username: String
}